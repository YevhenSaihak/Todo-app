
import { Injectable } from '@angular/core';
import { StorageMap } from '@ngx-pwa/local-storage';
import { Observable, of } from 'rxjs';
import { switchMap, delay, tap } from 'rxjs/operators';
import { TodoModel } from '../models/todo.model';

// Функція для генерації випадкової затримки 300–400 мс
const randomDelay = () => 300 + Math.floor(Math.random() * 100);

@Injectable({ providedIn: 'root' })
export class TodoService {
  private readonly STORAGE_KEY = 'todos';
  private todos: TodoModel[] = []; // Кеш у пам’яті

  constructor(private storage: StorageMap) {
    // Завантажуємо початковий список із LocalStorage
    this.storage
      .get<TodoModel[]>(this.STORAGE_KEY, { type: 'string' })
      .subscribe(stored => {
        // якщо в LS нічого немає — беремо пустий масив
        this.todos = stored ?? [];
      });
  }


    // Отримати всі TODO.
    // Спочатку повертаємо кеш, потім оновлюємо з LS із затримкою.

  getAll(): Observable<TodoModel[]> {
    return of(this.todos).pipe(
      switchMap(() =>
        this.storage.get<TodoModel[]>(this.STORAGE_KEY, { type: 'string' }).pipe(
          delay(randomDelay()),      // імітація затримки
          tap(fresh => {
            this.todos = fresh ?? []; // оновлюємо кеш
          }),
          switchMap(() => of(this.todos))
        )
      )
    );
  }


    // Створити новий TODO.
    // Додаємо в кеш і зберігаємо в LS із затримкою.

  create(todo: TodoModel): Observable<TodoModel> {
    this.todos = [...this.todos, todo];
    return of(todo).pipe(
      delay(randomDelay()),
      tap(() => {
        this.storage.set(this.STORAGE_KEY, this.todos).subscribe();
      })
    );
  }


    // Оновити існуючий TODO.
    // Модифікуємо кеш і оновлюємо LS.

  update(updated: TodoModel): Observable<TodoModel> {
    this.todos = this.todos.map(t => t.id === updated.id ? updated : t);
    return of(updated).pipe(
      delay(randomDelay()),
      tap(() => {
        this.storage.set(this.STORAGE_KEY, this.todos).subscribe();
      })
    );
  }


   // Видалити TODO за ідентифікатором.
   // Очищуємо кеш і LS.

  delete(id: string): Observable<void> {
    this.todos = this.todos.filter(t => t.id !== id);
    return of(undefined).pipe(
      delay(randomDelay()),
      tap(() => {
        this.storage.set(this.STORAGE_KEY, this.todos).subscribe();
      })
    );
  }


   // Переключити стан “в обране”. 
  // Знаходимо задачу, міняємо favorite і оновлюємо.

  toggleFavorite(id: string): Observable<TodoModel> {
    const todo = this.todos.find(t => t.id === id)!;
    const updated = { ...todo, favorite: !todo.favorite };
    return this.update(updated);
  }
}
